#!/usr/bin/env python

from __future__ import print_function

import logging
import subprocess
import os
import json
import argparse

logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt='%Y-%m-%dT%H:%M:%S'
)

_script_root = os.path.dirname(os.path.abspath(__file__))
_default_main = _script_root


def get_versions():
    return {"version": "0.1.0"}

def setup_conda_versions(main, versions):
    recipes = os.path.join(_script_root, "recipes")

    logging.info('versions:\n%s', json.dumps(versions, indent=2))
    dalphaball_version = versions["version"]

    with open(recipes + "/dalphaball/meta.version.yaml", "w") as of:
        of.write("""
package:
  version: {dalphaball_version}

source:
  path: '{main}'
""".format(**locals()))


def format_command(target, conda_args):
    recipe = os.path.join(_script_root , "recipes", target)

    def normarg(a):
        if a.count(" ") != 0 and not a.startswith('"'):
            return '"' + a + '"'
        else:
            return a

    return (
       "conda build --append-file {recipe}/meta.version.yaml {recipe} ".format(**locals()) +
       " ".join(map(normarg, conda_args))
   )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Build rosetta conda packages.')
    parser.add_argument(
        '--dry-run',
        default=False, action='store_true', help='Version and print build commands, do not build.')
    parser.add_argument("target",
        choices=["dalphaball"], nargs=1)
    parser.add_argument("conda",
        type=str, default=[], nargs=argparse.REMAINDER, help="Args to passthrough to conda build.")
    args = parser.parse_args()
    versions = get_versions()
    setup_conda_versions(_default_main, versions)

    cmd = format_command(args.target[0], args.conda)
    logging.info("%s:\n  %s", args.target[0], cmd)
    if not args.dry_run:
        subprocess.check_call(cmd, shell=True)
